<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AniList + hianime Player</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; max-width: 700px; }
  label { font-weight: bold; margin-top: 15px; display: block; }
  select, button, input { margin: 10px 0; padding: 8px; width: 100%; box-sizing: border-box; }
  #modal {
    display: none;
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    justify-content: center; align-items: center;
    z-index: 1000;
  }
  #modal iframe {
    width: 80%; height: 80%;
  }
  #modalClose {
    position: absolute; top: 20px; right: 30px;
    font-size: 30px; color: white; cursor: pointer;
  }
  #loadingEpisodes {
    color: green;
    font-style: italic;
    margin-top: 5px;
  }
</style>
</head>
<body>

<h1>AniList Anime Player with hianime Episode IDs</h1>

<label for="searchInput">Search Anime (e.g. "hero"):</label>
<input id="searchInput" type="text" placeholder="Type to search anime..." />

<label for="animeSlugInput">Enter hianime.to Anime Slug (e.g. magical-girl-site-5887):</label>
<input id="animeSlugInput" type="text" placeholder="Enter anime slug for hianime.to" />

<label for="animeSelect">Anime:</label>
<select id="animeSelect" disabled>
  <option value="" disabled selected>Select an anime</option>
</select>

<label for="episodeSelect">Episode:</label>
<select id="episodeSelect" disabled>
  <option value="" disabled selected>Select episode</option>
</select>

<label for="langSelect">Language:</label>
<select id="langSelect" disabled>
  <option value="sub">Sub</option>
  <option value="dub">Dub</option>
</select>

<button id="playBtn" disabled>Play</button>

<div id="loadingEpisodes"></div>

<div id="modal">
  <span id="modalClose">&times;</span>
  <iframe id="playerFrame" src="" frameborder="0" allowfullscreen scrolling="no"></iframe>
</div>

<script>
const searchInput = document.getElementById("searchInput");
const animeSlugInput = document.getElementById("animeSlugInput");
const animeSelect = document.getElementById("animeSelect");
const episodeSelect = document.getElementById("episodeSelect");
const langSelect = document.getElementById("langSelect");
const playBtn = document.getElementById("playBtn");
const modal = document.getElementById("modal");
const modalClose = document.getElementById("modalClose");
const playerFrame = document.getElementById("playerFrame");
const loadingEpisodes = document.getElementById("loadingEpisodes");

let currentAnimeList = [];
let episodeIdMap = {};

// AniList GraphQL query
const query = `
query ($search: String) {
  Page(page: 1, perPage: 10) {
    media(search: $search, type: ANIME) {
      id
      title {
        romaji
      }
      episodes
    }
  }
}
`;

// Debounce helper
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  };
}

// Fetch anime list
async function fetchAnimeList(searchTerm) {
  animeSelect.disabled = true;
  episodeSelect.disabled = true;
  langSelect.disabled = true;
  playBtn.disabled = true;
  animeSelect.innerHTML = '<option value="" disabled selected>Loading...</option>';
  episodeSelect.innerHTML = '<option value="" disabled selected>Select episode</option>';
  loadingEpisodes.textContent = "";
  episodeIdMap = {};

  try {
    const response = await fetch('https://graphql.anilist.co', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, variables: { search: searchTerm } })
    });
    const data = await response.json();
    if (data.errors) throw new Error(data.errors[0].message);
    return data.data.Page.media;
  } catch (e) {
    alert("Error fetching anime list: " + e.message);
    return [];
  }
}

// Try to fetch episode IDs from hianime.to page via CORS proxy
async function fetchEpisodeIdsFromHianime(slug) {
  loadingEpisodes.textContent = "Loading episode IDs from hianime.to...";
  episodeIdMap = {};

  if (!slug) {
    loadingEpisodes.textContent = "Please enter hianime.to anime slug above.";
    return;
  }

  // Use allorigins proxy to avoid CORS
  const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(`https://hianime.to/watch/${slug}`);

  try {
    const res = await fetch(proxyUrl);
    if (!res.ok) throw new Error("Failed to fetch proxy");
    const data = await res.json();

    const parser = new DOMParser();
    const doc = parser.parseFromString(data.contents, "text/html");

    // Clear old map
    episodeIdMap = {};

    // Find episode links â€” hianime's episode list might be inside <div class="episodes-list"> or <ul class="episodes-list">, or find all links with "?ep=" in href
    const links = [...doc.querySelectorAll('a[href*="?ep="]')];

    // Extract episode number and ep id from href and text
    links.forEach(link => {
      const href = link.getAttribute('href');
      const epParamMatch = href.match(/\?ep=(\d+)/);
      if (!epParamMatch) return;

      const epId = epParamMatch[1];
      const text = link.textContent.trim();

      // Try to get episode number from text like "Episode 2" or "2"
      let epNum = null;
      const epNumMatch = text.match(/(\d+)/);
      if (epNumMatch) epNum = epNumMatch[1];

      if (epNum) {
        episodeIdMap[epNum] = epId;
      }
    });

    loadingEpisodes.textContent = `Loaded episode IDs for ${Object.keys(episodeIdMap).length} episodes from hianime.to`;

  } catch (e) {
    loadingEpisodes.textContent = "Failed to load episode IDs automatically. You may need to enter manually.";
    console.warn("Error fetching episode IDs:", e);
  }
}

// Search input event (debounced)
const onSearchChange = debounce(async () => {
  const term = searchInput.value.trim();
  if (term.length < 2) {
    animeSelect.innerHTML = '<option value="" disabled selected>Type at least 2 chars to search</option>';
    animeSelect.disabled = true;
    episodeSelect.disabled = true;
    langSelect.disabled = true;
    playBtn.disabled = true;
    return;
  }

  currentAnimeList = await fetchAnimeList(term);

  animeSelect.innerHTML = '<option value="" disabled selected>Select an anime</option>';
  currentAnimeList.forEach((anime, idx) => {
    const epCountText = anime.episodes ? `(${anime.episodes} episodes)` : '(Unknown episodes)';
    const option = document.createElement("option");
    option.value = idx;
    option.textContent = `${anime.title.romaji} ${epCountText}`;
    animeSelect.appendChild(option);
  });
  animeSelect.disabled = currentAnimeList.length === 0;
  episodeSelect.disabled = true;
  langSelect.disabled = true;
  playBtn.disabled = true;
  loadingEpisodes.textContent = "";
}, 500);

// Event listeners
searchInput.addEventListener("input", onSearchChange);

animeSlugInput.addEventListener("change", () => {
  const slug = animeSlugInput.value.trim();
  if (slug) {
    fetchEpisodeIdsFromHianime(slug);
  } else {
    episodeIdMap = {};
    loadingEpisodes.textContent = "";
  }
});

animeSelect.addEventListener("change", () => {
  episodeSelect.innerHTML = '<option value="" disabled selected>Select episode</option>';
  langSelect.disabled = true;
  playBtn.disabled = true;

  const anime = currentAnimeList[animeSelect.value];
  if (!anime || !anime.episodes) {
    episodeSelect.disabled = true;
    return;
  }
  for(let i = 1; i <= anime.episodes; i++) {
    const option = document.createElement("option");
    option.value = i;
    option.textContent = `Episode ${i}`;
    episodeSelect.appendChild(option);
  }
  episodeSelect.disabled = false;
});

episodeSelect.addEventListener("change", () => {
  langSelect.disabled = true;
  playBtn.disabled = true;
  const epNum = episodeSelect.value;
  if (!epNum) return;

  // Check if we have epId from scraped map
  if (episodeIdMap[epNum]) {
    langSelect.disabled = false;
  } else {
    // Ask user to input manually if missing
    const epIdManual = prompt(`Episode ID for episode ${epNum} NOT found automatically.\nPlease enter the hianime episode ID (from ?ep= in URL), or Cancel to reselect episode.`);
    if (epIdManual && epIdManual.trim() !== "") {
      episodeIdMap[epNum] = epIdManual.trim();
      langSelect.disabled = false;
    } else {
      episodeSelect.value = "";
    }
  }
  playBtn.disabled = true;
});

langSelect.addEventListener("change", () => {
  playBtn.disabled = !(episodeSelect.value && langSelect.value);
});

playBtn.addEventListener("click", () => {
  const anime = currentAnimeList[animeSelect.value];
  const epNum = episodeSelect.value;
  const lang = langSelect.value;

  if (!anime || !epNum || !lang) return alert("Please select anime, episode and language.");

  const epId = episodeIdMap[epNum];
  if (!epId) return alert("Episode ID not found. Please enter it.");

  const embedUrl = `https://megaplay.buzz/stream/s-2/${epId}/${lang}`;
  playerFrame.src = embedUrl;
  modal.style.display = "flex";
});

modalClose.addEventListener("click", () => {
  modal.style.display = "none";
  playerFrame.src = "";
});

modal.addEventListener("click", e => {
  if (e.target === modal) {
    modalClose.click();
  }
});
</script>

</body>
</html>
